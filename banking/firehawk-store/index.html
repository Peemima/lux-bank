<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lux Banking Dashboard</title>
  <noscript>
    <h1>js_err_noscrpt_popup</h1>
    <p>A wild error popped out of nowhere!</p>
    <p>Tell Ian F about it immediately.</p>
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
  </noscript>
<link rel="stylesheet" href="/lux-bank/assets/styles.css">

  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js" defer></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js" defer></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getDatabase, ref, set, get } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyASd5JOikXTlRp8eA2j_26Z1NWatZMjZds",
        authDomain: "lux-bank.firebaseapp.com",
        databaseURL: "https://lux-bank-default-rtdb.firebaseio.com",
        projectId: "lux-bank",
        storageBucket: "lux-bank.appspot.com",
        messagingSenderId: "764922032293",
        appId: "1:764922032293:web:573599b6116f025ee15d4c",
        measurementId: "G-JQ7CWEJS9N"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    window.businessValue = "Firehawk Store";

    let currentSearchQuery = "";
    let expandedGradeLevels = JSON.parse(localStorage.getItem('expandedGradeLevels') || '[]'); // Load expanded states on start

    // Function to check if business account exists and create it if not
    function ensureBusinessAccountExists() {
      if (businessValue != null) {
        const businessRef = ref(database, `businesses/${businessValue}`);
        get(businessRef).then((snapshot) => {
          if (!snapshot.exists()) {
            // Business doesn't exist, create it with initial balance of 0
            set(businessRef, { balance: 0 }).then(() => {
              console.log(`Business "${businessValue}" created with balance: 0`);
            }).catch((error) => {
              console.error('Error creating business:', error);
            });
          }
        }).catch((error) => {
          console.error('Error checking for business existence:', error);
        });
      }
    }
    // Call the function to ensure business account exists on load
    document.addEventListener("DOMContentLoaded", function() {
      // ... (rest of your DOMContentLoaded code)
      ensureBusinessAccountExists();
    });

    document.addEventListener("DOMContentLoaded", function() {
      const searchForm = document.getElementById("searchForm");
      const resetButton = document.getElementById("resetButton");
      const searchInput = document.getElementById("searchInput");

      searchForm.addEventListener("submit", function(event) {
        event.preventDefault();
        currentSearchQuery = searchInput.value.trim().toLowerCase();
        fetchAndDisplayUsers(currentSearchQuery);
        resetButton.style.display = 'inline-block'; // Show reset button on search
      });

      resetButton.addEventListener("click", function() {
        searchInput.value = '';
        currentSearchQuery = '';
        fetchAndDisplayUsers();
        resetButton.style.display = 'none'; // Hide reset button
      });

      // Fetch and display users right away
      fetchAndDisplayUsers();
    });

// Function to handle collapse/expand of grade level sections
function toggleGradeLevelSection(event) {
    const header = event.currentTarget;
    const list = header.nextElementSibling; // The sibling div (grade-level-list)
    const gradeLevel = header.dataset.gradeLevel;

    header.classList.toggle('expanded');
    list.classList.toggle('collapsed');

    // Update expanded states in localStorage
    if (header.classList.contains('expanded')) {
        if (!expandedGradeLevels.includes(gradeLevel)) {
            expandedGradeLevels.push(gradeLevel);
        }
    } else {
        expandedGradeLevels = expandedGradeLevels.filter(g => g !== gradeLevel);
    }
    localStorage.setItem('expandedGradeLevels', JSON.stringify(expandedGradeLevels));
}

// Function to attach event listeners to grade level headers
function attachToggleListeners() {
    const headers = document.querySelectorAll('.grade-level-header');
    headers.forEach(header => {
        // Remove existing listener to prevent duplicates on refresh
        header.removeEventListener('click', toggleGradeLevelSection); 
        header.addEventListener('click', toggleGradeLevelSection);
    });
}


function fetchAndDisplayUsers(query = "") {
  get(ref(database, 'users')).then((snapshot) => {
    let content = "";
    if (snapshot.exists()) {
      const users = snapshot.val();
      const userList = Object.keys(users).map(key => ({ key, ...users[key] }));

      // Filter users based on query
      const filteredUsers = userList.filter(user => user.key.toLowerCase().includes(query));

      if (filteredUsers.length === 0) {
        // No user matches the search query, offer to add one
        content = `<div class="user-info"><p class="list-name">No matching users found.</p><button class="fill-button" onclick="addUser('${query}')">Add ${query}</button></div>`;
      } else {
        // Group users by gradeLevel
        const groupedUsers = {};
        filteredUsers.forEach(user => {
          const gradeLevel = user.gradeLevel != null ? user.gradeLevel : 0; // Default to 0 if gradeLevel is missing
          if (!groupedUsers[gradeLevel]) {
            groupedUsers[gradeLevel] = [];
          }
          groupedUsers[gradeLevel].push(user);
        });

        // Sort grade levels numerically
        const sortedGradeLevels = Object.keys(groupedUsers).sort((a, b) => parseInt(a) - parseInt(b));

        sortedGradeLevels.forEach(gradeLevel => {
          const gradeUsers = groupedUsers[gradeLevel].sort((a, b) => a.key.localeCompare(b.key)); // Sort users by name within grade
          const isExpanded = expandedGradeLevels.includes(gradeLevel); // Check if this grade was previously expanded
          const headerClass = isExpanded ? "grade-level-header expanded" : "grade-level-header";
          const listClass = isExpanded ? "grade-level-list" : "grade-level-list collapsed";

          content += `
            <div class="grade-level-section">
                <div class="${headerClass}" data-grade-level="${gradeLevel}">
                    <p>Grade Level ${gradeLevel}</p>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="${listClass}">
          `;

          gradeUsers.forEach((user, index) => {
            // Note: Removed positionClass logic as it's less relevant with the new grouping and borders
            // You might want to re-introduce specific first/last styling if needed.
            content += `<div class="user-info"><p class="list-name">${user.key}: $${user.balance}</p><button class="fill-button" onclick="openModal('${user.key}')">Select</button></div>`;
          });
          content += `</div></div>`; // Close grade-level-list and grade-level-section
        });
      }
    } else {
      // No users at all in the database
      content = `<div class="user-info"><p class="list-name">No users found.</p><button style="cursor: not-allowed;" disabled class="fill-button">Search to Add Users</button></div>`;
    }
    document.getElementById("allUsers").innerHTML = content;
    attachToggleListeners(); // Attach listeners after rendering new HTML
  }).catch((error) => {
    console.error("Error fetching users: ", error);
    document.getElementById("allUsers").innerText = 'Err_fetching_users: A wild error apeared! Contact Ian F *immediately*';
  });
}
    
// Modified addUser function to include a default gradeLevel
window.addUser = function(userName, gradeLevel = 1) { // Default gradeLevel 1 for new users
  const generateUserID = () => {
    return Math.floor(1000 + Math.random() * 9000).toString();
  };

  const checkUserIDUnique = (userID) => {
    // Check if the user ID (which is the actual name here) exists
    return get(ref(database, 'users/' + userName)).then((snapshot) => {
      return !snapshot.exists(); // Returns true if userName does not exist
    });
  };

  const createUser = (userID, userName, gradeLevel) => {
    const newUserRef = ref(database, 'users/' + userName);
    set(newUserRef, { 
      id: userID, 
      balance: 0,
      gradeLevel: gradeLevel // Include the grade level here
    }).then(() => {
      console.log('User added successfully.');
      fetchAndDisplayUsers(currentSearchQuery);
    }).catch((error) => {
      console.error('Error adding user:', error);
    });
  };

  const addUserWithUniqueID = async (userName, gradeLevel) => {
    let userID;
    let isUnique = false;

    // Check if the userName itself is unique first
    isUnique = await checkUserIDUnique(userName); 
    if (!isUnique) {
      console.log(`User "${userName}" already exists.`);
      // Optionally provide feedback to the user or prevent adding.
      // For now, we'll just not add if the name exists.
      return; 
    }

    // Generate a unique numeric ID for the 'id' property within the user object
    let numericID;
    let isNumericIDUnique = false;
    while (!isNumericIDUnique) {
        numericID = generateUserID();
        // This check would require iterating through all users to see if any have this 'id'
        // For simplicity, we'll assume generateUserID is sufficient for now, or you'd need a more complex query.
        // Or, more commonly, the key (userName) is the primary identifier, and 'id' is just an internal property.
        isNumericIDUnique = true; // Placeholder, assuming the userName is the unique identifier for simplicity
    }

    createUser(numericID, userName, gradeLevel);
  };

  addUserWithUniqueID(userName, gradeLevel);
};

    let selectedUserKey = ''; // To keep track of which user is selected

// After: Make openModal global by attaching it to the window object
window.openModal = function(userKey) {
  selectedUserKey = userKey; // Set the selected user key
  document.getElementById('modal-header').innerText = selectedUserKey;
  document.getElementById('userModal').style.display = 'block'; // Show the modal
  setTimeout(() => {
    const input = document.getElementById('amountInput');
    if (input){
      input.focus();
      console.log("157");
    }
  }, 50); // 50ms is usually
};

// Close the modal
document.querySelector('.close').addEventListener('click', function() {
  document.getElementById('userModal').style.display = 'none';
}); 

// Make addAmount global
window.addAmount = function() {
  const amount = Number(document.getElementById('amountInput').value);
  updateUserBalance(selectedUserKey, amount); // Positive amount for addition
};





//Jiggle when theres an input error: fix the weird charecter input problem
document.getElementById('amountInput').addEventListener('input', function(e) {
  // Remove any non-digit characters from the input.
  const validValue = this.value.replace(/[^0-9]/g, '');
  
  // Check if the input value is not solely composed of digits.
  if (this.value !== validValue) {
    // Replace the input value with the cleaned, digit-only version.
    this.value = validValue;
    
    // Add the 'jiggle' class to trigger the animation.
    this.classList.add('jiggle');
    
    // Automatically remove the 'jiggle' class after the animation ends (500ms) to reset the state.
    setTimeout(() => {
      this.classList.remove('jiggle');
    }, 500);
  }
});


// Update user balance and log the transaction
function updateUserBalance(userKey, amount) {
    const userRef = ref(database, 'users/' + userKey);

    // Fetch the current balance first
    get(userRef).then((snapshot) => {
        if (snapshot.exists()) {
            const userData = snapshot.val();
            let currentBalance = userData.balance;
            let newBalance = currentBalance + amount; // Calculate the new balance

            // Update the user's balance in Firebase
            set(ref(database, 'users/' + userKey), {
                id: userData.id, // Preserve existing id
                balance: newBalance,
                gradeLevel: userData.gradeLevel // Preserve existing gradeLevel
            }).then(() => {
                console.log('User balance updated successfully.');

                if (amount < 0) {
                    // Withdrawal - add the amount to the business account
                    updateBusinessBalance(Math.abs(amount));
                }

                // Log the transaction, passing in the business name
                logTransaction(userKey, amount, newBalance, businessValue, businessData);

                document.getElementById('userModal').style.display = 'none'; // Close the modal
                fetchAndDisplayUsers(currentSearchQuery); // Refresh user list after update
            }).catch((error) => {
                console.error('Error updating user balance:', error);
            });
        } else {
            console.log('No user found with the key:', userKey);
        }
    }).catch((error) => {
        console.error('Error fetching user data:', error);
    });
}




// Function to log transactions with unique IDs based on timestamp
function logTransaction(userKey, amount, newBalance, businessValue, businessBalanceAmount) {
    const transactionID = `trans_${Date.now()}_${Math.floor(Math.random() * 1000)}`; // Generate a unique ID

    const transactionRef = ref(database, 'transactions/' + transactionID); // Use the generated ID
    
    const transactionData = {
        userKey: userKey,
        amount: amount,
        newBalance: newBalance,
        businessBalance: businessBalanceAmount,
        business: businessValue, // Business name is captured here
        timestamp: Date.now() // Capturing the timestamp
    };

    set(transactionRef, transactionData)
        .then(() => {
            console.log('Transaction logged successfully.');
        })
        .catch((error) => {
            console.error('Error logging transaction:', error);
        });
}



// Function to update the business's balance: Adds the amount to the current balance
function updateBusinessBalance(amountToAdd) {
    const businessRef = ref(database, `businesses/${businessValue}/balance`);

    get(businessRef).then((snapshot) => {
        let newBalance;
        let currentBalance = snapshot.exists() ? snapshot.val() : 0; // Use current balance or default to 0

        // Addition of the given amount to the business balance
        newBalance = currentBalance + amountToAdd;

        // Update the balance in Firebase
        set(businessRef, newBalance).then(() => {
            console.log(`Business balance updated to ${newBalance}`);
        }).catch((error) => {
            console.error('Error updating business balance:', error);
        });

    }).catch((error) => {
        console.error('Error fetching business balance:', error);
        // Initialize if fetching fails and no balance is found (Handling edge case)
        set(businessRef, amountToAdd).then(() => {
            console.log('Business balance initialized and set to:', amountToAdd);
        }).catch((initError) => {
            console.error('Error initializing business balance:', initError);
        });
    });
}

window.withdrawAmount = function() {
    const amountInput = document.getElementById('amountInput');
    const amountToWithdraw = Number(amountInput.value);
    const userKey = selectedUserKey;
    const userRef = ref(database, `users/${userKey}`);

    // Fetch the current user balance first
    get(userRef).then((snapshot) => {
        if (snapshot.exists()) {
            const userData = snapshot.val();
            let currentBalance = userData.balance;
            if (amountToWithdraw > currentBalance) {
                // Trigger jiggle animation if withdrawal amount exceeds the balance
                amountInput.classList.add('jiggle');
                setTimeout(() => {
                    amountInput.classList.remove('jiggle');
                }, 500);
            } else {
                let newBalance = currentBalance - amountToWithdraw; // Calculate the new balance after withdrawal

                // Update the user's balance in Firebase
                set(ref(database, 'users/' + userKey), {
                    id: userData.id, // Preserve existing id
                    balance: newBalance,
                    gradeLevel: userData.gradeLevel // Preserve existing gradeLevel
                }).then(() => {
                    console.log('Withdrawal successful, user balance updated.');

                    // This will add the withdrawn amount to the business balance
                    updateBusinessBalance(amountToWithdraw);

                    // Log the withdrawal transaction, note here the amount is negative
                    logTransaction(userKey, -amountToWithdraw, newBalance, businessValue, businessData);

                    // Close the modal
                    document.getElementById('userModal').style.display = 'none';
                    fetchAndDisplayUsers(currentSearchQuery); // Refresh user list after update
                }).catch((error) => {
                    console.error('Error updating user balance:', error);
                });
            }
        } else {
            console.log('User balance could not be found.');
        }
    }).catch((error) => {
        console.error('Error fetching user balance:', error);
    });
};




function fetchAndDisplayBusinessBalance() {
  const businessRef = ref(database, `businesses/${businessValue}`);
  get(businessRef).then((snapshot) => {
    if (snapshot.exists()) {
      window.businessData = snapshot.val();
      document.getElementById('businessBalance').innerText = `Store earnings: $${businessData.balance}`;
    } else {
      console.error('Business data not found');
    }
  }).catch((error) => {
    console.error('Error fetching business balance:', error);
  });
}

//Code to automsticly update users and business balances

// Call this function to initially display the balance and inside updateBusinessBalance to update it
setInterval(fetchAndDisplayBusinessBalance, 5000);

setInterval(() => {
  fetchAndDisplayUsers(currentSearchQuery); // Use the updated query for auto-refresh
}, 5000); // Adjust the timing as necessary

fetchAndDisplayBusinessBalance()
  </script>
</head>
<body>
  <div id="businessInfo" style="display: grid; grid-template-columns: 1fr auto 1fr;">
  <span id="businessName" style="float: left;"><h1 style="font-family: Poppins;">Firehawk Store</h1></span>
    <img class="logo" src="/lux-bank/assets/fireyhills.png">
  <span id="businessBalance" style="float: right; text-align: right;">...</span>
</div>

  <form id="searchForm">
    <input type="text" id="searchInput" placeholder="Search users...">
    <button class="fill-button" type="submit">Search</button>
    <button id="resetButton" style="display: none;" class="outline-button">Reset</button>
  </form>
  <div id="allUsers" class="container"></div>
  <!-- The Modal -->
<div id="userModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2 id="modal-header" style="font-family: 'poppins';">Edit User Balance</h2>
    <p>Transactions are measured in Hawkeyes.</p>
    <!-- Form to add or withdraw -->
    <input type="text" id="amountInput" placeholder="Enter amount..." pattern="\d*">
    <button class="fill-button" disabled onclick="addAmount()">Add</button>
    <button class="outline-button" onclick="withdrawAmount()">Withdraw</button>
  </div>
</div>

</body>
</html>
