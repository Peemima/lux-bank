<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lux Banking Dashboard</title>
  <noscript>
    <h1>js_err_noscrpt_popup</h1>
    <p>A wild error popped out of nowhere!</p>
    <p>Tell Ian F about it immediately.</p>
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
  </noscript>
<link rel="stylesheet" href="/lux-bank/assets/styles.css">

  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js" defer></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js" defer></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getDatabase, ref, set, get } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyASd5JOikXTlRp8eA2j_26Z1NWatZMjZds",
        authDomain: "lux-bank.firebaseapp.com",
        databaseURL: "https://lux-bank-default-rtdb.firebaseio.com",
        projectId: "lux-bank",
        storageBucket: "lux-bank.appspot.com",
        messagingSenderId: "764922032293",
        appId: "1:764922032293:web:573599b6116f025ee15d4c",
        measurementId: "G-JQ7CWEJS9N"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    window.businessValue = "Firehawk Store";

    let currentSearchQuery = "";

    // Function to check if business account exists and create it if not
    function ensureBusinessAccountExists() {
      if (businessValue != null) {
        const businessRef = ref(database, `businesses/${businessValue}`);
        get(businessRef).then((snapshot) => {
          if (!snapshot.exists()) {
            // Business doesn't exist, create it with initial balance of 0
            set(businessRef, { balance: 0 }).then(() => {
              console.log(`Business "${businessValue}" created with balance: 0`);
            }).catch((error) => {
              console.error('Error creating business:', error);
            });
          }
        }).catch((error) => {
          console.error('Error checking for business existence:', error);
        });
      }
    }
    // Call the function to ensure business account exists on load
    document.addEventListener("DOMContentLoaded", function() {
      // ... (rest of your DOMContentLoaded code)
      ensureBusinessAccountExists();
    });

    document.addEventListener("DOMContentLoaded", function() {
      const searchForm = document.getElementById("searchForm");
      searchForm.addEventListener("submit", function(event) {
        event.preventDefault();
        currentSearchQuery = document.getElementById("searchInput").value.trim().toLowerCase();
        fetchAndDisplayUsers(currentSearchQuery); // Make sure you pass currentSearchQuery when fetching users
      });

      // Fetch and display users right away
      fetchAndDisplayUsers();
    });

    // Modified fetchAndDisplayUsers to group by grade
    function fetchAndDisplayUsers(query = "") {
      get(ref(database, 'users')).then((snapshot) => {
        const allUsersDiv = document.getElementById("allUsers");
        allUsersDiv.innerHTML = ""; // Clear previous content

        if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
          allUsersDiv.innerHTML = `<div class="user-info"><p class="list-name">No users found.</p></div>`;
          // Allow adding a user only if the search query is not empty
          if (query.length > 0) {
            allUsersDiv.innerHTML += `<div class="user-info"><button class="fill-button" onclick="promptAndAddUser('${query}')">Add "${query}"</button></div>`;
          }
          return;
        }

        const usersData = snapshot.val();
        const groupedUsers = {}; // To store users by grade
        let hasMatchingUsers = false; // Flag to check if any user matches the query

        // Populate groupedUsers and filter by query
        Object.keys(usersData).forEach(userName => {
          const user = usersData[userName];
          const userGrade = user.gradeLevel || 'Unassigned'; // Default grade if not present

          // Filter by search query
          if (userName.toLowerCase().includes(query.toLowerCase())) {
            hasMatchingUsers = true;
            if (!groupedUsers[userGrade]) {
              groupedUsers[userGrade] = [];
            }
            groupedUsers[userGrade].push({ name: userName, ...user });
          }
        });

        // Sort grades (e.g., numerically for "Grade X", "Unassigned" last)
        const sortedGrades = Object.keys(groupedUsers).sort((a, b) => {
          if (a === 'Unassigned') return 1;
          if (b === 'Unassigned') return -1;
          const gradeA = parseInt(a.replace(/\D/g, '')) || 0;
          const gradeB = parseInt(b.replace(/\D/g, '')) || 0;
          return gradeA - gradeB;
        });

        let content = "";
        if (sortedGrades.length === 0 && query.length > 0) {
          // No matching users found for the query in any grade
          content += `<div class="user-info"><p class="list-name">No matching users found for "${query}".</p><button class="fill-button" onclick="promptAndAddUser('${query}')">Add "${query}"</button></div>`;
        } else if (sortedGrades.length === 0) {
          // This case should ideally be caught by the initial `!snapshot.exists()` check
          content += `<div class="user-info"><p class="list-name">No users found.</p></div>`;
        } else {
          sortedGrades.forEach(grade => {
            const usersInGrade = groupedUsers[grade];
            // Only create a details section if there are users for this grade after filtering
            if (usersInGrade && usersInGrade.length > 0) {
                content += `<details open><summary class="grade-summary">${grade}</summary><div class="grade-list">`;
                usersInGrade.forEach((user, index) => {
                    let listItemClass = 'user-info'; // Base class
                    let specificClass = '';
                    if(usersInGrade.length === 1) {
                        specificClass = 'only-user-in-grade';
                    } else if(index === 0){
                        specificClass = 'first-user-in-grade';
                    } else if(index === usersInGrade.length - 1){
                        specificClass = 'last-user-in-grade';
                    } else {
                        specificClass = 'middle-user-in-grade';
                    }
                    content += `<div class="${listItemClass} ${specificClass}"><p class="list-name">${user.name}: $${user.balance}</p><button class="fill-button" onclick="openModal('${user.name}')">Select</button></div>`;
                });
                content += `</div></details>`;
            }
          });
          // If after iterating grades, no content was added (meaning no users matched query across any grade)
          if (content === "" && query.length > 0) {
            content += `<div class="user-info"><p class="list-name">No matching users found for "${query}".</p><button class="fill-button" onclick="promptAndAddUser('${query}')">Add "${query}"</button></div>`;
          }
        }
        allUsersDiv.innerHTML = content;
      }).catch((error) => {
        console.error("Error fetching users: ", error);
        document.getElementById("allUsers").innerText = 'Err_fetching_users: A wild error apeared! Contact Ian F *immediately*';
      });
    }

    // New helper function to prompt for grade and then add user
    window.promptAndAddUser = function(userName) {
        const gradeInput = prompt(`Enter grade for "${userName}": (e.g., "Grade 9", "Faculty", "Staff")`);
        if (gradeInput !== null && gradeInput.trim() !== '') {
            addUser(userName, 0, gradeInput.trim()); // Call addUser with grade and default balance
        } else if (gradeInput !== null) { // User clicked OK but entered nothing
            alert('Grade cannot be empty. User not added.');
        }
        // If gradeInput is null, user cancelled the prompt. Do nothing.
    };

    // Modified addUser function to accept grade
    window.addUser = function(userName, startingBalance, grade) {
      const generateUserID = () => {
        return Math.floor(1000 + Math.random() * 9000).toString();
      };

      const checkUserIDUnique = (userID) => {
        // Checking for ID uniqueness is generally done against a dedicated 'ids' node or by iterating users,
        // but for simplicity, we'll check against a potential 'users/{userID}' path which is not how IDs are currently stored.
        // Given current structure is 'users/{userName}', ID is a property. This check needs review for actual uniqueness requirement.
        // For now, let's assume `id` as a property inside the user object and simply assign a random one.
        // If actual ID uniqueness across all users is needed, a different strategy is required (e.g., a separate /userIDs list).
        return Promise.resolve(true); // Temporarily bypass actual ID check as IDs are internal properties not keys.
      };

      const createUser = (userID, userName, startingBalance, grade) => {
        const newUserRef = ref(database, 'users/' + userName);
        set(newUserRef, { 
          id: userID, 
          balance: startingBalance,
          grade: grade || 'Unassigned' // Assign grade, or 'Unassigned' if not provided
        }).then(() => {
          console.log('User added successfully.');
          fetchAndDisplayUsers(currentSearchQuery);
        }).catch((error) => {
          console.error('Error adding user:', error);
        });
      };

      const addUserWithUniqueID = async (userName, startingBalance, grade) => {
        let userID;
        let isUnique = false;

        while (!isUnique) {
          userID = generateUserID();
          isUnique = await checkUserIDUnique(userID); // This is simplified, see notes above
        }

        createUser(userID, userName, startingBalance, grade);
      };

      addUserWithUniqueID(userName, startingBalance, grade);
    };

    let selectedUserKey = ''; // To keep track of which user is selected

    // After: Make openModal global by attaching it to the window object
    window.openModal = function(userKey) {
      selectedUserKey = userKey; // Set the selected user key
      document.getElementById('modal-header').innerText = selectedUserKey;
      document.getElementById('userModal').style.display = 'block'; // Show the modal
      setTimeout(() => {
        const input = document.getElementById('amountInput');
        if (input){
          input.focus();
        }
      }, 50); // 50ms is usually
    };

    // Close the modal
    document.querySelector('.close').addEventListener('click', function() {
      document.getElementById('userModal').style.display = 'none';
      document.getElementById('amountInput').value = ''; // Clear input on close
    }); 

    // Make addAmount global
    window.addAmount = function() {
      const amount = Number(document.getElementById('amountInput').value);
      if (isNaN(amount) || amount <= 0) {
          document.getElementById('amountInput').classList.add('jiggle');
          setTimeout(() => document.getElementById('amountInput').classList.remove('jiggle'), 500);
          return;
      }
      updateUserBalance(selectedUserKey, amount); // Positive amount for addition
    };

    //Jiggle when theres an input error: fix the weird charecter input problem
    document.getElementById('amountInput').addEventListener('input', function(e) {
      // Remove any non-digit characters from the input.
      const validValue = this.value.replace(/[^0-9]/g, '');
      
      // Check if the input value is not solely composed of digits.
      if (this.value !== validValue) {
        // Replace the input value with the cleaned, digit-only version.
        this.value = validValue;
        
        // Add the 'jiggle' class to trigger the animation.
        this.classList.add('jiggle');
        
        // Automatically remove the 'jiggle' class after the animation ends (500ms) to reset the state.
        setTimeout(() => {
          this.classList.remove('jiggle');
        }, 500);
      }
    });


    // Update user balance and log the transaction
    function updateUserBalance(userKey, amount) {
        const userRef = ref(database, 'users/' + userKey);

        // Fetch the current balance first
        get(userRef).then((snapshot) => {
            if (snapshot.exists()) {
                const userData = snapshot.val();
                let currentBalance = userData.balance;
                let newBalance = currentBalance + amount; // Calculate the new balance

                // Update the user's balance in Firebase
                set(ref(database, 'users/' + userKey), {
                    id: userData.id, // Preserve existing ID
                    balance: newBalance,
                    grade: userData.grade || 'Unassigned' // Preserve existing grade or default
                }).then(() => {
                    console.log('User balance updated successfully.');

                    // Determine the business balance update action
                    let businessBalanceUpdatePromise = Promise.resolve(window.businessData?.balance || 0); // Default to current loaded balance
                    if (amount < 0) { // If it's a withdrawal from the user
                        businessBalanceUpdatePromise = updateBusinessBalance(Math.abs(amount));
                    } else { // If it's an addition to the user (implies withdrawal from business, if business is the source)
                        // If `addAmount` means money from business, we'd do `updateBusinessBalance(-amount)` here.
                        // Based on existing code (withdrawAmount adds to business), `addAmount` means money comes from outside business or is added to both, so business balance isn't explicitly changed here.
                        // Assuming `window.businessData` is kept up-to-date by the interval.
                        businessBalanceUpdatePromise = get(ref(database, `businesses/${businessValue}/balance`)).then(snap => snap.val() || 0);
                    }

                    businessBalanceUpdatePromise.then((updatedBusinessBalance) => {
                        logTransaction(userKey, amount, newBalance, businessValue, updatedBusinessBalance);
                        document.getElementById('userModal').style.display = 'none'; // Close the modal
                        document.getElementById('amountInput').value = ''; // Clear input
                    });
                }).catch((error) => {
                    console.error('Error updating user balance:', error);
                });
            } else {
                console.log('No user found with the key:', userKey);
            }
        }).catch((error) => {
            console.error('Error fetching user data:', error);
        });
    }

    // Function to log transactions with unique IDs based on timestamp
    function logTransaction(userKey, amount, newBalance, businessValue, businessBalanceAmount) {
        const transactionID = `trans_${Date.now()}_${Math.floor(Math.random() * 1000)}`; // Generate a unique ID

        const transactionRef = ref(database, 'transactions/' + transactionID); // Use the generated ID
        
        const transactionData = {
            userKey: userKey,
            amount: amount,
            newBalance: newBalance,
            businessBalance: businessBalanceAmount,
            business: businessValue, // Business name is captured here
            timestamp: Date.now() // Capturing the timestamp
        };

        set(transactionRef, transactionData)
            .then(() => {
                console.log('Transaction logged successfully.');
            })
            .catch((error) => {
                console.error('Error logging transaction:', error);
            });
    }

    // Function to update the business's balance: Adds the amount to the current balance
    // Now returns a Promise that resolves with the new business balance
    function updateBusinessBalance(amountToAdd) {
        const businessRef = ref(database, `businesses/${businessValue}/balance`);

        return get(businessRef).then((snapshot) => {
            let newBalance;
            let currentBalance = snapshot.exists() ? snapshot.val() : 0; // Use current balance or default to 0

            newBalance = currentBalance + amountToAdd;

            return set(businessRef, newBalance).then(() => {
                console.log(`Business balance updated to ${newBalance}`);
                return newBalance; // Return the new balance
            }).catch((error) => {
                console.error('Error updating business balance:', error);
                throw error; // Re-throw to propagate the error
            });
        }).catch((error) => {
            console.error('Error fetching business balance:', error);
            // Initialize if fetching fails and no balance is found (Handling edge case)
            return set(businessRef, amountToAdd).then(() => {
                console.log('Business balance initialized and set to:', amountToAdd);
                return amountToAdd; // Return the initial amount
            }).catch((initError) => {
                console.error('Error initializing business balance:', initError);
                throw initError;
            });
        });
    }

    window.withdrawAmount = function() {
        const amountInput = document.getElementById('amountInput');
        const amountToWithdraw = Number(amountInput.value);
        const userKey = selectedUserKey;
        const userRef = ref(database, `users/${userKey}`);

        if (isNaN(amountToWithdraw) || amountToWithdraw <= 0) {
            amountInput.classList.add('jiggle');
            setTimeout(() => amountInput.classList.remove('jiggle'), 500);
            return;
        }

        // Fetch the current user balance first
        get(userRef).then((snapshot) => {
            if (snapshot.exists()) {
                const userData = snapshot.val();
                let currentBalance = userData.balance;
                if (amountToWithdraw > currentBalance) {
                    // Trigger jiggle animation if withdrawal amount exceeds the balance
                    amountInput.classList.add('jiggle');
                    setTimeout(() => {
                        amountInput.classList.remove('jiggle');
                    }, 500);
                } else {
                    let newBalance = currentBalance - amountToWithdraw; // Calculate the new balance after withdrawal

                    // Update the user's balance in Firebase
                    set(ref(database, 'users/' + userKey), {
                        id: userData.id, // Preserve existing ID
                        balance: newBalance,
                        grade: userData.grade || 'Unassigned' // Preserve existing grade or default
                    }).then(() => {
                        console.log('Withdrawal successful, user balance updated.');

                        // This will add the withdrawn amount to the business balance
                        updateBusinessBalance(amountToWithdraw).then((updatedBusinessBalance) => {
                            // Log the withdrawal transaction, note here the amount is negative
                            logTransaction(userKey, -amountToWithdraw, newBalance, businessValue, updatedBusinessBalance);

                            // Close the modal and clear input
                            document.getElementById('userModal').style.display = 'none';
                            document.getElementById('amountInput').value = '';
                        });
                    }).catch((error) => {
                        console.error('Error updating user balance:', error);
                    });
                }
            } else {
                console.log('User balance could not be found.');
            }
        }).catch((error) => {
            console.error('Error fetching user balance:', error);
        });
    };

    function fetchAndDisplayBusinessBalance() {
      const businessRef = ref(database, `businesses/${businessValue}`);
      get(businessRef).then((snapshot) => {
        if (snapshot.exists()) {
          window.businessData = snapshot.val();
          document.getElementById('businessBalance').innerText = `Store earnings: $${businessData.balance}`;
        } else {
          console.error('Business data not found');
        }
      }).catch((error) => {
        console.error('Error fetching business balance:', error);
      });
    }

    //Code to automsticly update users and business balances
    setInterval(fetchAndDisplayBusinessBalance, 5000);

    setInterval(() => {
      fetchAndDisplayUsers(currentSearchQuery); // Use the updated query for auto-refresh
    }, 5000); // Adjust the timing as necessary

    fetchAndDisplayBusinessBalance()
  </script>
</head>
<body>
  <div id="businessInfo" style="display: grid; grid-template-columns: 1fr auto 1fr;">
    <span id="businessName" style="float: left;"><h1 style="font-family: Poppins;">Firehawk Store</h1></span>
    <img class="logo" src="/lux-bank/assets/fireyhills.png">
    <span id="businessBalance" style="float: right; text-align: right;">...</span>
  </div>

  <form id="searchForm">
    <input type="text" id="searchInput" placeholder="Search users...">
    <button class="fill-button" type="submit">Search</button>
    <button id="resetButton" style="display: none;" class="outline-button">Reset</button>
  </form>
  <div id="allUsers" class="container"></div>
  <!-- The Modal -->
<div id="userModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2 id="modal-header" style="font-family: 'poppins';">Edit User Balance</h2>
    <p>Transactions are measured in Hawkeyes.</p>
    <!-- Form to add or withdraw -->
    <input type="text" id="amountInput" placeholder="Enter amount..." pattern="\d*">
    <button class="fill-button" onclick="addAmount()">Add</button>
    <button class="outline-button" onclick="withdrawAmount()">Withdraw</button>
  </div>
</div>

</body>
</html>
